<!DOCTYPE html>
<html lang="en">
<head>
    <title>Cardboard Example</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            margin: 0px;
            overflow: hidden;
        }

        #example {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }

        .crossImg {
            position: fixed;
            width: 40px;
            height: 40px;
            top: 50%;
        }

        #crossImg {
            left: 25%;
            -webkit-transform: translate(-25%, -50%);
            transform: translate(-25%, -50%);
        }

        #crossImg2 {
            left: 75%;
            -webkit-transform: translate(-75%, -50%);
            transform: translate(-75%, -50%);
        }

    </style>
</head>
<body>

<div id="example">
    <div id="text"></div>
    <img class="crossImg" id="crossImg" src="img/circle.gif"/>
    <img class="crossImg" id="crossImg2" src="img/circle.gif"/>
</div>
<!--<iframe src="https://www.casino.com/uk/games/hlf2/halloween-fortune-ii/?mode=practice" style="position: absolute; z-index:999999999; top:0; left:0; width: 100%; height:100%;"></iframe>-->
<script src="build/three.js"></script>
<script src="js/third-party/threejs/StereoEffect.js"></script>
<script src="js/third-party/threejs/DeviceOrientationControls.js"></script>
<script src="js/third-party/threejs/OrbitControls.js"></script>
<script src="js/NoSleep.min.js"></script>

<script>
    var camera, cube, scene, renderer;
    var effect, controls;
    var element, container;
    var images_per_row;
    var vectors = {};
    var planes = {};
    var menu_items = [];
    var defaults = {}
    var clock = new THREE.Clock();
    var lock = false;
    var moved = false;

    init();
    animate();

    var noSleep = new NoSleep();

    function enableNoSleep() {
        noSleep.enable();
        document.removeEventListener('touchstart', enableNoSleep, false);
    }

    // Enable wake lock.
    // (must be wrapped in a user input event handler e.g. a mouse or touch handler)
    document.addEventListener('touchstart', enableNoSleep, false);

    // ...

    // Disable wake lock at some point in the future.
    // (does not need to be wrapped in any user input event handler)
    noSleep.disable();

    function init() {
        renderer = new THREE.WebGLRenderer();
        element = renderer.domElement;
        container = document.getElementById('example');
        container.appendChild(element);

        effect = new THREE.StereoEffect(renderer);

        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.001, 700);
        scene.add(camera);

        scene.background = new THREE.CubeTextureLoader()
                .setPath('img/textures/santamaria/')
                .load(['px.jpg', 'nx.jpg', 'py.jpg', 'ny.jpg', 'pz.jpg', 'nz.jpg']);


        var textureCube = new THREE.CubeTextureLoader()
                .setPath('img/textures/santamaria/')
                .load(['px.jpg', 'nx.jpg', 'py.jpg', 'ny.jpg', 'pz.jpg', 'nz.jpg']);
        textureCube.mapping = THREE.CubeRefractionMapping;

        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);


        controls = new THREE.OrbitControls(camera, element);
//		controls.rotateUp(Math.PI / 4);
        controls.target.set(
                camera.position.x + 0.1,
                camera.position.y,
                camera.position.z
        );
        controls.noZoom = true;
        controls.noPan = true;

        images_per_row = 8;
        addGameImages(150, images_per_row, 0, 0);
        addGameImages(150, images_per_row, 0, 1);


        function setOrientationControls(e) {
            if (!e.alpha) {
                return;
            }

            controls = new THREE.DeviceOrientationControls(camera, true);
            controls.connect();
            controls.update();
            element.addEventListener('click', fullscreen, false);

            window.removeEventListener('deviceorientation', setOrientationControls, true);
        }

        window.addEventListener('deviceorientation', setOrientationControls, true);


        var light = new THREE.HemisphereLight(0x777777, 0x000000, 0.9);
        scene.add(light);

        window.addEventListener('resize', resize, false);
        setTimeout(resize, 1);
    }
    function addMenu(base_distance, total, current_rotation, row) {
        var game_geometry = new THREE.PlaneGeometry(100, 147 * 0.4);
        base_distance = 150;
        total = 8;
        current_rotation = 0;

        for (var i = 1; i <= total; i++) {
            var game_image = new THREE.MeshBasicMaterial({map: THREE.ImageUtils.loadTexture('img/menu_images/' + i + '.jpg')});
            menu_item = new THREE.Mesh(game_geometry, game_image);
            current_rotation = 360 / total + current_rotation;
            menu_item.rotation.y = (current_rotation * Math.PI) / 180;

            var sin = [0, 180, 360];
            var cos = [90, 270];

            menu_item.position.x = sin.indexOf(current_rotation) > -1 ? 0 : -base_distance * Math.sin((current_rotation * Math.PI) / 180);
            menu_item.position.y = row * 100;
            menu_item.position.z = cos.indexOf(current_rotation) > -1 ? 0 : -base_distance * Math.cos((current_rotation * Math.PI) / 180);
            menu_item.castShadow = true;
            menu_item.receiveShadow = true;
            menu_item.name = 'gameImg' + i;
            menu_items.push(menu_item);

            scene.add(menu_item);
        }
    }

    function addGameImages(base_distance, total, current_rotation, row) {
        var game_geometry = new THREE.PlaneGeometry(100, 147 * 0.4);
        if (!vectors[row]) {
            vectors[row] = Math.sqrt(Math.pow(base_distance, 2) + Math.pow(row * 100, 2));
        }

        for (var i = 1; i <= total; i++) {
            var game_image = new THREE.MeshBasicMaterial({map: THREE.ImageUtils.loadTexture('img/game_images/' + i + '.jpg')});
            plane = new THREE.Mesh(game_geometry, game_image);

            current_rotation = 360 / total + current_rotation;
            plane.rotation.y = (current_rotation * Math.PI) / 180;

            var sin = [0, 180, 360];
            var cos = [90, 270];

            plane.position.x = sin.indexOf(current_rotation) > -1 ? 0 : -base_distance * Math.sin((current_rotation * Math.PI) / 180);
            plane.position.y = row * 100;
            plane.position.z = cos.indexOf(current_rotation) > -1 ? 0 : -base_distance * Math.cos((current_rotation * Math.PI) / 180);
            planes[row] = planes[row] || [];
            planes[row].push(plane);

            defaults[row] = defaults[row] || [];
            defaults[row].push({
                position: {
                    x: plane.position.x,
                    y: plane.position.y,
                    z: plane.position.z
                },
                rotation: {
                    y: plane.rotation.y
                },
                index: (planes.length - 1),
                row: row
            });

            scene.add(plane);
        }
    }

    function gameEntryAnimation(num) {
        var sin = [0, 180, 360];
        var cos = [90, 270];
        var elem = planes[num];
        var current_rotation = (elem.rotation.y / Math.PI) * 180;
        console.log(current_rotation);
        var pos = 950;
        var id = setInterval(frame, 5);

        function frame() {
            if (pos == 150) {
                clearInterval(id);
            } else {
                pos -= 5;
                elem.position.x = sin.indexOf(current_rotation) > -1 ? 0 : -pos * Math.sin((current_rotation * Math.PI) / 180);
                elem.position.z = cos.indexOf(current_rotation) > -1 ? 0 : -pos * Math.cos((current_rotation * Math.PI) / 180);
                console.log(elem.position.x, elem.position.z)
            }
        }
    }

    function resize() {
        var width = container.offsetWidth;
        var height = container.offsetHeight;

//		camera.aspect = width / height;
//		camera.updateProjectionMatrix();

        renderer.setSize(width, height);
        effect.setSize(width, height);
    }

    function update(dt) {
        resize();

        camera.updateProjectionMatrix();

        controls.update(dt);
    }

    function render(dt) {
//		console.log(camera.rotation.y);
        effect.render(scene, camera);
        gamePointer();
//		var rotation = camera.getWorldDirection();
//		console.log(rotation.x * 180 / Math.PI);

    }

    var current_row = 0;
    var row_defaults = defaults[current_row];
    var row_planes = planes[current_row];

    function gamePointer() {
        var camera_rotation_y = Math.abs(camera.rotation.y / Math.PI * 180) > 180 ? (camera.rotation.y / Math.PI * 180) - 360 : (camera.rotation.y / Math.PI * 180);
        var camera_rotation_x = camera.rotation.x / Math.PI * 180;//Math.abs(camera.rotation.x / Math.PI * 180) > 180 ? (camera.rotation.x / Math.PI * 180) - 360 : (camera.rotation.x / Math.PI * 180);

        for (var v in vectors) {
            var sin = Math.abs(v * 100) / vectors[v];
            var deg = sin == 0 ? 0 : (Math.asin(sin) / Math.PI) * 180;
            deg = v >= 0 ? deg : deg * -1;

            var up = v >= 0 && camera_rotation_x < (deg + 14) && camera_rotation_x > (deg - 14);
            var down = v < 0 && camera_rotation_x < (deg + 14) && camera_rotation_x > (deg - 14);
            if (up || down) {
                document.getElementById('text').innerHTML =  'Row: ' + v + ' - ' + camera_rotation_x + ' - ' + (deg + 14) + ' - ' + (deg - 14);

                if (current_row != v) {
                    for (var plane in row_planes) {
                        row_planes[plane].position.z = row_defaults[plane].position.z;
                        row_planes[plane].position.x = row_defaults[plane].position.x;
                    }

                    current_row = v;
                    row_defaults = defaults[current_row];
                    row_planes = planes[current_row];
                }
            }
        }

        for (var i = 0; i < row_defaults.length; i++) {
            var plane_rotation = Math.abs(row_planes[i].rotation.y / Math.PI * 180) > 180 ? (row_planes[i].rotation.y / Math.PI * 180) - 360 : (row_planes[i].rotation.y / Math.PI * 180);
            if (camera_rotation_y < plane_rotation + 10 && camera_rotation_y > plane_rotation - 10) {
                if (!lock && row_planes && row_planes.length > 0) {
                    row_planes[i].position.z = row_planes[i].position.z == 0 ? 0 : row_planes[i].position.z > 0 ? row_planes[i].position.z - 30 : row_planes[i].position.z + 30;
                    row_planes[i].position.x = row_planes[i].position.x == 0 ? 0 : row_planes[i].position.x > 0 ? row_planes[i].position.x - 30 : row_planes[i].position.x + 30;

                    lock = true;
                    moved = i;
                    window.navigator && window.navigator.vibrate ? window.navigator.vibrate(200) : {};
                    break;
                }
            }
            else if (moved !== false && moved === i && row_planes && row_planes.length > 0) {
                row_planes[moved].position.z = row_defaults[moved].position.z;
                row_planes[moved].position.x = row_defaults[moved].position.x;
                lock = false;
                moved = false;
                break;
            }
        }
    }

    var degrees = function (radians) {
        return radians;
    };
    function animate(t) {
        requestAnimationFrame(animate);

        update(clock.getDelta());
        render(clock.getDelta());
    }

    setTimeout(animateAll, 10000);
    setTimeout(entryAll, 10500);

    function entryAll() {
        for (var i = 0; i < 8; i++) {
            gameEntryAnimation(i);
        }
    }
    function animateAll() {
        for (var i = 0; i < 8; i++) {
            animateMe(i);
        }
        addGameImages(950, 8, 0, 0);
    }
    function animateMe(num) {
        var elem = menu_items[num];
        var pos = 0;
        var id = setInterval(frame, 5);

        function frame() {
            if (elem.position.y == 100) {
                clearInterval(id);
            } else {
                pos += 2;
                elem.position.y = pos;
            }
        }
    }
    setTimeout(shrinkCrosshair, 5000);
    function shrinkCrosshair() {
        var elem1 = document.getElementById('crossImg');
        var elem2 = document.getElementById('crossImg2');
        var pos = 40;
        var id = setInterval(frame, 10);

        function frame() {
            if (pos <= 20) {
                clearInterval(id);
            } else {
                pos -= 0.1;
                elem1.style.height = pos + "px";
                elem1.style.width = pos + "px";

                elem2.style.height = pos + "px";
                elem2.style.width = pos + "px";
            }
        }
    }
    function fullscreen() {
        if (container.requestFullscreen) {
            container.requestFullscreen();
        } else if (container.msRequestFullscreen) {
            container.msRequestFullscreen();
        } else if (container.mozRequestFullScreen) {
            container.mozRequestFullScreen();
        } else if (container.webkitRequestFullscreen) {
            container.webkitRequestFullscreen();
        }
    }
</script>
</body>
</html>
